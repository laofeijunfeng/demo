# 自动内存管理机制

### 概述
对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

### 运行时数据区域
java 虚拟机所管理的内存包含以下几个运行时数据区域：
<div align="center">  
<img src="https://raw.githubusercontent.com/laofeijunfeng/demo/master/images/jvm/20190513155216.png" width="600px"/>
</div>

#### 程序计数器
线程私有

程序计数器是一块较小的空间，可看作是当前线程锁执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

每个线程都拥有各自的程序计数器，来使得虚拟机的多线程轮流切换时互不干扰。

如果执行 java 方法时，计数器记录的是正在执行虚拟机字节码指令的地址，如果是 Native 方法，则为空。

注意：此内存区域是唯一一个在 java 虚拟机规范中没有规定任何 OutOfMemoryError 的内存区域。

#### Java 虚拟机栈
线程私有

虚拟机栈描述的是 java 方法执行的内存模型：每个方法在执行时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成就对应一个栈帧入栈到出栈的过程。

一般人们把 java 内存分为堆内存和栈内存，其中栈就是指虚拟机栈。

局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

**虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError：**
* StackOverFlowError：线程请求的栈深度大于虚拟机所允许的深度。
* OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

#### 本地方法栈
和虚拟机栈相似，区别是虚拟机栈为 Java 方法服务，而本地方法栈为 Native 方法服务。

#### Java 堆
堆是 Java 虚拟机所管理内存中最大的一块，几乎所有的对象实例和数组都在这里分配。

堆是垃圾收集器管理的主要区域，**从垃圾回收的角度**，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存**。
**从内存分配的角度看**，线程共享的 Java 堆中可能划分多个线程私有的分配缓冲区（TLAB）。

堆可以处于物理上不连续，逻辑上连续即可。

#### 方法区
和堆一样，也是线程共享的区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

垃圾收集器在这个区域回收的目标主要是针对常量池的回收和对类型的卸载，是比较少出现的。

方法区无法满足内存分配需求时，则会抛出 OutOfMemoryError 异常。

#### 运行时常量池
运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。

<div align="center">  
<img src="https://raw.githubusercontent.com/laofeijunfeng/demo/master/images/jvm/20190513171215.png" width="600px"/>
</div>

