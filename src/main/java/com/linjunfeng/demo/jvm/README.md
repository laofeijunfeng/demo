# 自动内存管理机制

### 概述
对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

### 运行时数据区域
java 虚拟机所管理的内存包含以下几个运行时数据区域：
<div align="center">  
<img src="https://raw.githubusercontent.com/laofeijunfeng/demo/master/images/jvm/20190513155216.png" width="600px"/>
</div>

#### 程序计数器
线程私有

程序计数器是一块较小的空间，可看作是当前线程锁执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

每个线程都拥有各自的程序计数器，来使得虚拟机的多线程轮流切换时互不干扰。

如果执行 java 方法时，计数器记录的是正在执行虚拟机字节码指令的地址，如果是 Native 方法，则为空。

注意：此内存区域是唯一一个在 java 虚拟机规范中没有规定任何 OutOfMemoryError 的内存区域。

#### Java 虚拟机栈
线程私有

虚拟机栈描述的是 java 方法执行的内存模型：每个方法在执行时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成就对应一个栈帧入栈到出栈的过程。\

一般人们把 java 内存分为堆内存和栈内存，其中栈就是指虚拟机栈。

局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

**虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError：**
* StackOverFlowError：线程请求的栈深度大于虚拟机所允许的深度。
* OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

