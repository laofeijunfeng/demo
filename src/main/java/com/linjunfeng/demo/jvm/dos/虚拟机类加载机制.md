目录
=
* [虚拟机类加载机制](#虚拟机类加载机制)
    * [一 概述](#概述)
    * [二 类加载机制的时机](#类加载时机)
    * [三 类加载的过程](#类加载的过程)
        * [3.1 加载](#加载)
        * [3.2 验证](#验证)
        * [3.3 准备](#准备)
        * [3.4 解析](#解析)
        * [3.5 初始化](#初始化)
    * [四 类加载器](#类加载器)
        * [4.1 类与类加载器](#类与类加载器)
        * [4.2 双亲委派模型](#双亲委派模型)

# 虚拟机类加载机制

## 概述

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

Java 类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时增加一些性能开小，但是可以提高灵活度，可以动态扩展的语言特性就是依赖运行期间动态加载和动态连接实现的。

## 类加载时机

类从被加载到虚拟机内存中开始，到卸载出内存结束，包含 5 个阶段：
<div align="center">  
<img src="https://raw.githubusercontent.com/laofeijunfeng/demo/master/images/jvm/20190530164437.png" width="800px"/>
</div>

**加载**阶段虚拟机没有强制规定什么时候开始，但是**初始化**则有：
* 遇到 new、getstatic、putstatic、invokestatic 这 4 个指令时，如果类没有初始化，则需要初始化；
* 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果没哟初始化，则触发初始化；
* 初始化一个类时，发现其父类没有初始化，则先触发父类进行初始化；
* 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类；
* 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且方法句柄对应的类没有初始化时，则先触发初始化；

## 类加载的过程

### 加载

在**加载**阶段，虚拟机需要完成 3 件事：
1. 通过全限定名来定义二进制字节流（class 文件即二进制文件）；
2. 將字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个累的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口；

而 Class 文件获取：
* 从 ZIP 包读，比如常见的 jar、ear、war 格式；
* 从网络中读，典型的应用是 Applet；
* 其他文件生成，典型的常见是 JSP 应用，即由 JSP 文件生成对应的 Class 类；
...

加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个 java.lang.Class 类的对象。

### 验证

主要是确保 Class 文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机本身。

Java 语言本身如果不规范，编译期间编译器会直接报错，而 Class 文件并不一定来自 Java 语言，所以验证阶段非常重要。

验证 4 个阶段：
1. 文件格式验证（魔数、版本号等）
2. 元数据验证（父类是否允许继承、字段方法等是否与父类发生冲突等）
3. 字节码验证（对方法体验证）
4. 符号引用验证

在实际开发中，如果全部代码都已经验证过，可考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机加载的时间。

### 准备

这时候是正式给**类变量( static 修饰的)**在**方法区**分配内存和设置初始值(零值)的阶段，实例变量(非 static 变量)则是在对象实例化时分配到 Java 堆中的。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
* 符号引用：是以任何形式的字面量，只要使用时能无歧义的定位到目标即可；
* 直接引用：可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄；

### 初始化

初始化阶段就是执行类构造器方法的过程，主要是给类变量赋值和执行静态语句块。

## 类加载器

### 类与类加载器

类加载器只用于实现类的加载动作，而在 Java 中，加载器会配合类本身来确定在虚拟机中的唯一性，也就是说，如果两个类来源于同一个 Class 文件，但是加载器不同，则两个类不相等。

### 双亲委派模型

Java 虚拟机有两种不同的类加载器：
* 启动类加载器，C++ 实现，是虚拟机的一部分；
* 所有其他的类加载器，由 Java 实现，独立于虚拟机外部，都继承自 java.lang.ClassLoader；

Java 程序都会使用的 3 种类加载器：
1. 启动类加载器，主要负责 lib 目录中的，或被 -Xbootclasspath 参数指定路径中的，且虚拟机识别的类库加载到内存中；
2. 扩展类加载器，负责加载 lib/ext 目录中的，或被 java.ext.dirs 系统变量执行路径中的类库；
3. 应用程序类加载器，负责加载用户类路径上所指定的类库；

如果有需要， 用户还可以加入自己定义的类加载器，关系如下：
<div align="center">  
<img src="https://raw.githubusercontent.com/laofeijunfeng/demo/master/images/jvm/20190531101527.png" width="600px"/>
</div>

这种层次称为类加载器的双亲委派模型。要求除了顶层启动类加载器外，其余类加载器都应有自己的父类加载器。不过这里的父子类关系是组合而非继承。

双亲委派模型的工作是：如果一个类加载器收到请求，首先会把请求委派给父类去完成，层层递上，当父加载器无法完成加载，子加载器才会尝试自己去加载。